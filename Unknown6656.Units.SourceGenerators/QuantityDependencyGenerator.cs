using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;

namespace Unknown6656.Units.Internals;


[Generator(LanguageNames.CSharp)]
public sealed class QuantityDependencyGenerator
    : ISourceGenerator
{
    public const string TYPE_QUANTITYDEPENDENCYATTRIBUTE = "QuantityDependency";

    private const string ERROR_BASE_ID = "U6656_";
    private static readonly DiagnosticDescriptor _diagnostic_requires_record = new (
        ERROR_BASE_ID + "QuantityRecordRequired",
        "The target quantity type must be declared as record.",
        "The target quantity type '{0}' must be declared as record.",
        "Unknown6656.Units",
        DiagnosticSeverity.Error,
        true
    );
    private static readonly DiagnosticDescriptor _diagnostic_requires_partial = new(
        ERROR_BASE_ID + "QuantityPartialRequired",
        "The target quantity type must be declared as 'partial'.",
        "The target quantity type '{0}' must be declared as 'partial'.",
        "Unknown6656.Units",
        DiagnosticSeverity.Error,
        true
    );
    private static readonly DiagnosticDescriptor _diagnostic_requires_record_as_attribute_argument = new(
        ERROR_BASE_ID + "QuantityRecordRequiredAsAttributeArgument",
        "The target quantity type must be part of the attribute type arguments.",
        "The target quantity type '{0}' must be part of the attribute type arguments.",
        "Unknown6656.Units",
        DiagnosticSeverity.Error,
        true
    );


    public void Initialize(GeneratorInitializationContext context) => context.RegisterForSyntaxNotifications(() => new QuantityDependencySyntaxReceiver());

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is QuantityDependencySyntaxReceiver receiver)
        {
            StringBuilder sb = new();

            sb.AppendLine("// <auto-generated/>");

            foreach (var usage in receiver.QuantityDependencies)
                if (usage.TargetType.Modifiers.IndexOf(SyntaxKind.PartialKeyword) < 0)
                    context.ReportDiagnostic(Diagnostic.Create(_diagnostic_requires_record, usage.TargetType.GetLocation(), [usage.TargetType.Identifier]));
                else if (usage.TargetType is RecordDeclarationSyntax record)
                {
                    TypeSyntax[] genargs = usage.GenericArguments;
                    TypeSyntax t_quantity_in1, t_quantity_in2, t_quantity_out,
                               t_baseunit_in1, t_baseunit_in2, t_baseunit_out,
                               t_scalar;

                    //if (!genargs.OfType<IdentifierNameSyntax>().Any(t => record.Identifier == t.Identifier))
                    //{
                    //    context.ReportDiagnostic(Diagnostic.Create(_diagnostic_requires_record_as_attribute_argument, record.GetLocation(), [record.Identifier]));
                    //
                    //    continue;
                    //}

                    (t_quantity_in1, t_quantity_in2, t_quantity_out, t_baseunit_in1, t_baseunit_in2, t_baseunit_out, t_scalar) = genargs.Length switch
                    {
                        7 => (genargs[0], genargs[1], genargs[2], genargs[3], genargs[4], genargs[5], genargs[6]),
                        5 => (genargs[0], genargs[0], genargs[1], genargs[2], genargs[2], genargs[3], genargs[4]),
                    };

                    sb.AppendLine($$""""
                    namespace {{usage.Namespace}}
                    {
                        public partial record {{record.ClassOrStructKeyword}} {{record.Identifier}}{{record.TypeParameterList}}
                        {
                            // TODO
                        }

                        partial record {{t_quantity_in1}}
                        {
                            public static {{t_quantity_out}} operator *({{t_quantity_in1}} first, {{t_quantity_in2}} second) => new(first.Value * second.Value);
                            public static {{t_quantity_in2}} operator /({{t_quantity_out}} first, {{t_quantity_in1}} second) => new(first.Value / second.Value);
                    """");

                    if (t_quantity_in1 != t_quantity_in2)
                        sb.AppendLine($$""""
                            public static {{t_quantity_out}} operator *({{t_quantity_in2}} first, {{t_quantity_in1}} second) => new(first.Value * second.Value);
                        }

                        partial record {{t_quantity_in2}}
                        {
                            public static {{t_quantity_in1}} operator /({{t_quantity_out}} first, {{t_quantity_in2}} second) => new(first.Value / second.Value);
                    """");

                    sb.AppendLine($$""""
                        }

                        partial record {{t_baseunit_in1}}
                        {
                            public static {{t_baseunit_out}} operator *({{t_baseunit_in1}} first, {{t_baseunit_in2}} second) => new(first.Value * second.Value);
                            public static {{t_baseunit_in2}} operator /({{t_baseunit_out}} first, {{t_baseunit_in1}} second) => new(first.Value / second.Value);
                    """");

                    if (t_baseunit_in1 != t_baseunit_in2)
                        sb.AppendLine($$""""
                            public static {{t_baseunit_out}} operator *({{t_baseunit_in2}} first, {{t_baseunit_in1}} second) => new(first.Value * second.Value);
                        }

                        partial record {{t_baseunit_in2}}
                        {
                            public static {{t_baseunit_in1}} operator /({{t_baseunit_out}} first, {{t_baseunit_in2}} second) => new(first.Value / second.Value);
                    """");

                    sb.AppendLine($$""""
                        }
                    }

                    """");
                }
                else
                    context.ReportDiagnostic(Diagnostic.Create(_diagnostic_requires_record, usage.TargetType.GetLocation(), [usage.TargetType.Identifier]));

            context.AddSource($"{typeof(QuantityDependencyGenerator)}.g.cs", sb.ToString());
        }
    }
}

public sealed record GenericAttributeClassUsage(string Namespace, TypeDeclarationSyntax TargetType, TypeSyntax[] GenericArguments, AttributeArgumentSyntax[] AttributeArguments)
{
    public static GenericAttributeClassUsage[] GetAttributes(SyntaxNode node, string[] names)
    {
        if (node is TypeDeclarationSyntax type_declaration)
        {
            string @namespace = type_declaration.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault()?.Name.ToString() ?? "";

            return [..from attributes in type_declaration.AttributeLists
                      from attribute in attributes.Attributes
                      let generic_name = attribute.Name as GenericNameSyntax
                      where generic_name is { }
                      let name = generic_name.Identifier.ToString()
                      where names.Contains(name)
                      let generic_arguments = generic_name.TypeArgumentList.Arguments.ToArray()
                      let arguments = attribute.ArgumentList?.Arguments.ToArray() ?? []

                      // TODO

                      select new GenericAttributeClassUsage(@namespace, type_declaration, generic_arguments, arguments)];
        }
        else
            return [];
    }
}

public sealed class QuantityDependencySyntaxReceiver
    : ISyntaxReceiver
{
    public List<GenericAttributeClassUsage> QuantityDependencies { get; } = [];

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode) =>
        QuantityDependencies.AddRange(GenericAttributeClassUsage.GetAttributes(syntaxNode, [QuantityDependencyGenerator.TYPE_QUANTITYDEPENDENCYATTRIBUTE]));
}
